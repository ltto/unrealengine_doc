{
  "application_families": [
    "unreal_engine"
  ],
  "applications": [
    {
      "id": 3581142,
      "major_version": "5",
      "type": "unreal_engine",
      "version": "5.5"
    }
  ],
  "blocks": [
    {
      "content_html": "\u003ch2\u003eNavigation\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API\"\u003eUnreal Engine C++ API Reference\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins\"\u003ePlugins\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities\"\u003eGameplayAbilities\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eReferences\u003c/h2\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003e \u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eModule\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities\"\u003eGameplayAbilities\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eHeader\u003c/td\u003e\n      \u003ctd\u003e/Engine/Plugins/Runtime/GameplayAbilities/Source/GameplayAbilities/Public/GameplayPrediction.h\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eInclude\u003c/td\u003e\n      \u003ctd\u003e#include \"GameplayPrediction.h\"\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eSyntax\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003eUSTRUCT \u0026#40;\u0026#41;  \nstruct FPredictionKey  \n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eRemarks\u003c/h2\u003e\n\n\u003cp\u003eOverview of Gameplay Ability Prediction\u003c/p\u003e\n\n\u003cp\u003eHigh Level Goals: At the GameplayAbility level (implementing an ability) prediction is transparent. An ability says \"Do X-\u003eY-\u003eZ\", and we will automatically predict the parts of that that we can. We wish to avoid having logic such as \"If Authority: Do X. Else: Do predictive version of X\" in the ability itself.\u003c/p\u003e\n\n\u003cp\u003eAt this point, not all cases are solved, but we have a very solid framework for working with client side prediction.\u003c/p\u003e\n\n\u003cp\u003eWhen we say \"client side prediction\" we really mean client predicting game simulation state. Things can still be 'completely client side' without having to work within a prediction system. For example, footsteps are completely client side and never interact with this system. But clients predicting their mana going from 100 to 90 when they cast a spell is 'client side prediction'.\u003c/p\u003e\n\n\u003cp\u003eWhat do we currently predict? -Initial GameplayAbility activation (and chained activation with caveats) -Triggered Events -GameplayEffect application: -Attribute modification (EXCEPTIONS: Executions do not currently predict, only attribute modifiers) -GameplayTag modification -Gameplay Cue events (both from within predictive gameplay effect and on their own)\u003c/p\u003e\n\n\u003cp\u003e-Montages -Movement (built into UE UCharacterMovement)\u003c/p\u003e\n\n\u003cp\u003eSome things we don't predict (most of these we potentially could, but currently dont): -GameplayEffect removal -GameplayEffect periodic effects (dots ticking)\u003c/p\u003e\n\n\u003cp\u003eProblems we attempt to solve:\u003c/p\u003e\n\n\u003cp\u003e\"Can I do this?\" Basic protocol for prediction.\u003c/p\u003e\n\n\u003cp\u003e\"Undo\" How to undo side effects when a prediction fails.\u003c/p\u003e\n\n\u003cp\u003e\"Redo\" How to avoid replaying side effects that we predicted locally but that also get replicated from the server.\u003c/p\u003e\n\n\u003cp\u003e\"Completeness\" How to be sure we /really/ predicted all side effects.\u003c/p\u003e\n\n\u003cp\u003e\"Dependencies\" How to manage dependent prediction and chains of predicted events.\u003c/p\u003e\n\n\u003cp\u003e\"Override\" How to override state predictively that is otherwise replicated/owned by the server.\u003c/p\u003e\n\n\u003cp\u003eImplementation Details\u003c/p\u003e\n\n\u003cp\u003e*** PredictionKey ***\u003c/p\u003e\n\n\u003cp\u003eA fundamental concept in this system is the Prediction Key (\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e). A prediction key on its own is simply a unique ID that is generated in a central place on the client. The client will send its prediction key to the server, and associate predictive actions and side effects with this key. The server may respond with an accept/reject for the prediction key, and will also associate the server-side created side effects with this prediction key.\u003c/p\u003e\n\n\u003cp\u003e(IMPORTANT) \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e always replicate client -\u003e server, but when replicating server -\u003e clients they \u003cem\u003eonly\u003c/em\u003e replicate to the client that sent the prediction key to the server in the first place. This happens in \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NetSerialize\"\u003eFPredictionKey::NetSerialize\u003c/a\u003e. All other clients will receive an invalid (0) prediction key when a prediction key sent from a client is replicated back down through a replicated property.\u003c/p\u003e\n\n\u003cp\u003e*** Ability Activation ***\u003c/p\u003e\n\n\u003cp\u003eAbility Activation is a first class predictive action  it generates an initial prediction key. Whenever a client predictively activates an ability, it explicitly asks the server and the server explicitly responds. Once an ability has been predictively activated (but the request has not yet been sent), the client has a valid 'prediction window' where predictive side effects can happen which are not explicitly 'asked about'. (E.g., we do not explicitly ask 'Can I decrement mana, Can I put this ability on cooldown. Those actions are considered logically atomic with activating an ability). You can think of this prediction window as being the initial callstack of ActivateAbility. Once ActivateAbility ends, your prediction window (and therefore your prediction key) is no longer valid. This is important, because many things can invalidate your prediction window such as any timers or latent nodes in your Blueprint; we do not predict over multiple frames.\u003c/p\u003e\n\n\u003cp\u003eAbilitySystemComponent provides a set of functions for communicating ability activation between clients and server: TryActivateAbility -\u003e ServerTryActivateAbility -\u003e ClientActivateAbility(Failed/Succeed).\u003c/p\u003e\n\n\u003cp\u003eClient calls TryActivateAbility which generates a new \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e and calls ServerTryActivateAbility.\u003c/p\u003e\n\n\u003cp\u003eClient continues (before hearing back from server) and calls ActivateAbility with the generated PredictionKey associated with the Ability's ActivationInfo.\u003c/p\u003e\n\n\u003cp\u003eAny side effects that happen /before the call to ActivateAbility finish/ have the generated \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e associated with them.\u003c/p\u003e\n\n\u003cp\u003eServer decides if the ability really happened in ServerTryActivateAbility, calls ClientActivateAbility(Failed/Succeed) and sets UAbilitySystemComponent::ReplicatedPredictionKey to the generated key that was sent with the request by the client.\u003c/p\u003e\n\n\u003cp\u003eIf client receives ClientAbilityFailed, it immediately kills the ability and rolls back side effects that were associated with the prediction key. 5a. 'Rolling back' logic is registered via \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKeyDelegates\"\u003eFPredictionKeyDelegates\u003c/a\u003e and \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NewRejectedDelegate\"\u003eFPredictionKey::NewRejectedDelegate\u003c/a\u003e/NewCaughtUpDelegate/NewRejectOrCaughtUpDelegate. 5b. ClientAbilityFailed is really the only case where we 'reject' prediction keys and thus all of our current predictions rely on if an ability activates or not.\u003c/p\u003e\n\n\u003cp\u003eIf ServerTryActivateAbility succeeds, client must wait until property replication catches up (the Succeed RPC will be sent immediately, property replication will happen on its own). Once the ReplicatedPredictionKey catches up to the key used previous steps, the client can undo its predictive side effects. See FReplicatedPredictionKeyItem::OnRep for the CatchUpTo logic. See UAbilitySystemComponent::ReplicatedPredictionKeyMap for how the keys actually get replicated. See ~FScopedPredictionWindow where the server acknowledges keys.\u003c/p\u003e\n\n\u003cp\u003e*** GameplayEffect Prediction ***\u003c/p\u003e\n\n\u003cp\u003eGameplayEffects are considered side effects of ability activation and are not separately accepted/rejected.\u003c/p\u003e\n\n\u003cp\u003eGameplayEffects are only applied on clients if there is a valid prediction key. (If no prediction key, it simply skips the application on client).\u003c/p\u003e\n\n\u003cp\u003eAttributes, GameplayCues, and GameplayTags are all predicted if the GameplayEffect is predicted.\u003c/p\u003e\n\n\u003cp\u003eWhen the \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffect\"\u003eFActiveGameplayEffect\u003c/a\u003e is created, it stores the prediction key (\u003ca href=\"https://dev.epicgames.com/documentation/404\"\u003eFActiveGameplayEffect::PredictionKey\u003c/a\u003e) 3a. Instant effects are explained below in \"Attribute Prediction\".\u003c/p\u003e\n\n\u003cp\u003eOn the server, the same prediction key is also set on the server's \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffect\"\u003eFActiveGameplayEffect\u003c/a\u003e that will be replicated down.\u003c/p\u003e\n\n\u003cp\u003eAs a client, if you get a replicated \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffect\"\u003eFActiveGameplayEffect\u003c/a\u003e with a valid prediction key on it, you check to see if you have an ActiveGameplayEffect with that same key, if there is match, we do not apply the 'on applied' type of logic, e.g., GameplayCues. The solves the \"Redo\" problem. However we will have 2 of the 'same' GameplayEffects in our ActiveGameplayEffects container, temporarily:\u003c/p\u003e\n\n\u003cp\u003eAt the same time, FReplicatedPredictionKeyItem::OnRep will catch up and the predictive effects will be removed. When they are removed in this case, we again check PredictionKey and decide if we should not do the 'On Remove' logic / GameplayCue.\u003c/p\u003e\n\n\u003cp\u003eAt this point, we have effectively predicted a gameplay effect as a side effect and handled the 'Undo' and 'Redo' problems.\u003c/p\u003e\n\n\u003cp\u003eSee \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffectsContainer/ApplyGameplayEff-\"\u003eFActiveGameplayEffectsContainer::ApplyGameplayEffectSpec\u003c/a\u003e where it registers what to do when caught-up (RemoveActiveGameplayEffect_NoReturn). See \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffect/PostReplicatedAdd\"\u003eFActiveGameplayEffect::PostReplicatedAdd\u003c/a\u003e, \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayEffect/PreReplicatedRemove\"\u003eFActiveGameplayEffect::PreReplicatedRemove\u003c/a\u003e, and \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FActiveGameplayCue/PostReplicatedAdd\"\u003eFActiveGameplayCue::PostReplicatedAdd\u003c/a\u003e for examples of how \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e is associated with the GE's and GC's.\u003c/p\u003e\n\n\u003cp\u003e*** Attribute Prediction ***\u003c/p\u003e\n\n\u003cp\u003eSince attributes are replicated as standard uproperties, predicting modification to them can be tricky (\"Override\" problem). Instantaneous modification can be even harder since these are non stateful by nature. (E.g., rolling back an attribute mod is difficult if there is no book keeping past the modification). This makes the \"Undo\" and \"Redo\" problem also hard in this case.\u003c/p\u003e\n\n\u003cp\u003eThe basic plan of attack is to treat attribute prediction as delta prediction rather than absolute value prediction. We do not predict that we have 90 mana, we predict that we have -10 mana from the server value, until the server confirms our prediction key. Basically, treat instant modifications as /infinite duration modifications/ to attributes while they are done predictively. The solves \"Undo\" and \"Redo\".\u003c/p\u003e\n\n\u003cp\u003eFor the \"override\" problem, we can handle this in the properties OnRep by treating the replicated (server) value as the 'base value' instead of 'final value' of the attribute, and to reaggregate our 'final value' after a replication happens.\u003c/p\u003e\n\n\u003cp\u003eWe treat predictive instant gameplay effects as infinite duration gameplay effects. See UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf.\u003c/p\u003e\n\n\u003cp\u003eWe have to \u003cem\u003ealways\u003c/em\u003e receive RepNotify calls on our attributes (not just when there is a change from last local value, since we will predict the change ahead of time). Done with REPNOTIFY_Always.\u003c/p\u003e\n\n\u003cp\u003eIn the attribute RepNotify, we call into the AbilitySystemComponent::ActiveGameplayEffects to update our 'final value' give the new 'base value'. the GAMEPLAYATTRIBUTE_REPNOTIFY can do this.\u003c/p\u003e\n\n\u003cp\u003eEverything else will work like above (GameplayEffect prediction) : when the prediction key is caught up, the predictive GameplayEffect is removed and we will return to the server given value.\u003c/p\u003e\n\n\u003cp\u003eExample:\u003c/p\u003e\n\n\u003cp\u003evoid UMyHealthSet::GetLifetimeReplicatedProps(TArray\u003c FLifetimeProperty \u003e \u0026 OutLifetimeProps) const { Super::GetLifetimeReplicatedProps(OutLifetimeProps);\u003c/p\u003e\n\n\u003cp\u003eDOREPLIFETIME_CONDITION_NOTIFY(UMyHealthSet, Health, COND_None, REPNOTIFY_Always); }\u003c/p\u003e\n\n\u003cp\u003evoid UMyHealthSet::OnRep_Health() { GAMEPLAYATTRIBUTE_REPNOTIFY(UMyHealthSet, Health); }\u003c/p\u003e\n\n\u003cp\u003e*** Gameplay Cue Events ***\u003c/p\u003e\n\n\u003cp\u003eOutside of GameplayEffects which are already explained, Gameplay Cues can be activated on their own. These functions (UAbilitySystemComponent::ExecuteGameplayCue etc) take network role and prediction keys into account.\u003c/p\u003e\n\n\u003cp\u003eIn UAbilitySystemComponent::ExecuteGameplayCue, if authority then do the multicast event (with replication key). If non authority but w/ a valid prediction key, predict the GameplayCue.\u003c/p\u003e\n\n\u003cp\u003eOn the receiving end (NetMulticast_InvokeGameplayCueExecuted etc), if there is a replication key, then don't do the event (assume you predicted it).\u003c/p\u003e\n\n\u003cp\u003eRemember that FPredictionKeys only replicate to the originating owner. This is an intrinsic property of FReplicationKey.\u003c/p\u003e\n\n\u003cp\u003e*** Triggered Data Prediction ***\u003c/p\u003e\n\n\u003cp\u003eTriggered Data is currently used to activate abilities. Essentially this all goes through the same code path as ActivateAbility. Rather than the ability being activated from input press, it is activated from another game code driven event. Clients are able to predictively execute these events which predictively activate abilities.\u003c/p\u003e\n\n\u003cp\u003eThere are some nuances to however, since the server will also run the code that triggers events. The server won't just wait to hear from the client. The server will keep a list of triggered abilities that have been activated from a predictive ability. When receiving a TryActivate from a triggered ability, the server will look to see if /it/ has already run this ability, and respond with that information.\u003c/p\u003e\n\n\u003cp\u003eThe issue is we do not properly rollback these operations. There is work left to do on Triggered Events and replication. (explained at the end).\u003c/p\u003e\n\n\u003cp\u003eAdvanced topic!\u003c/p\u003e\n\n\u003cp\u003e*** Dependencies ***\u003c/p\u003e\n\n\u003cp\u003eWe can have situations such as \"Ability X activates and immediately triggers an event which activates Ability Y which triggers another Ability Z\". The dependency chain is X-\u003eY-\u003eZ. Each of those abilities could be rejected by the server. If Y is rejected, then Z also never happened, but the server never tries to run Z, so the server doesn't explicitly decide 'no Z can't run'.\u003c/p\u003e\n\n\u003cp\u003eTo handle this, we have a concept of a Base PredictionKey, which is a member of \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e. When calling TryActivateAbility, we pass in the current PredictionKey (if applicable). That prediction key is used as the base for any new prediction keys generated. We build a chain of keys this way, and can then invalidate Z if Y is rejected.\u003c/p\u003e\n\n\u003cp\u003eThis is slightly more nuanced though. In the X-\u003eY-\u003eZ case, the server will only receive the PredictionKey for X before trying to run the chain itself. E.g., it will TryActivate Y and Z with the original prediction key sent to it from the client, whereas the client will generate a new PredictionKey each time it calls TryActivateAbility. The client \u003cem\u003ehas\u003c/em\u003e to generate a new PredictionKey for each ability activate, since each activate is not logically atomic. Each side effect produced in the chain of events has to have a unique PredictionKey. We cannot have GameplayEffects produced in X have the same PredictionKey produced in Z.\u003c/p\u003e\n\n\u003cp\u003eTo get around this, The prediction key of X is considered the Base key for Y and Z. The dependency from Y to Z is kept completely client side, which is done in by FPredictionKeyDelegates::AddDependancy. We add delegates to reject/catchup Z if Y rejected/confirmed.\u003c/p\u003e\n\n\u003cp\u003eThis dependency system allows us to have multiple predictive actions that are not logically atomic within a single prediction window/scope.\u003c/p\u003e\n\n\u003cp\u003eThere is a problem though: because the dependencies are kept client side, the server does not actually know if it had previously rejected a dependent action. You can design around this issue by using activation tags in your gameplay abilities. For instance, when predicting dependents GA_Combo1 -\u003e GA_Combo2, you could make GA_Combo2 only activate if it has a GameplayTag given by GA_Combo1. Thus a rejection of GA_Combo1 would also cause the server to reject the activation of GA_Combo2.\u003c/p\u003e\n\n\u003cp\u003e*** Additional Prediction Windows (within an Ability) ***\u003c/p\u003e\n\n\u003cp\u003eAs stated, A prediction key is only usable during a single logical scope. Once ActivateAbility returns, we are essentially done with that key. If the ability is waiting on an external event or timer, it's possible we will have already received a confirm/reject from the server by the time we're ready to continue execution. Thus any additional side effects produced after the initial activation can no longer be tied to the lifespan of the original key.\u003c/p\u003e\n\n\u003cp\u003eThis isn't that bad, except that abilities will sometimes want to react to player input. For example, 'a hold down and charge' ability wants to instantly predict some stuff when the button is released. It is possible to create a new prediction window within an ability with \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FScopedPredictionWindow\"\u003eFScopedPredictionWindow\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eFScopedPredictionWindows provides a way to send the server a new prediction key and have the server pick up and use that key within the same logical scope.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/Abilities/Tasks/UAbilityTask_WaitInputRelease/OnReleaseCallbac-\"\u003eUAbilityTask_WaitInputRelease::OnReleaseCallback\u003c/a\u003e is a good example. The flow of events is as followed:\u003c/p\u003e\n\n\u003cp\u003eClient enters \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/Abilities/Tasks/UAbilityTask_WaitInputRelease/OnReleaseCallbac-\"\u003eUAbilityTask_WaitInputRelease::OnReleaseCallback\u003c/a\u003e and starts a new \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FScopedPredictionWindow\"\u003eFScopedPredictionWindow\u003c/a\u003e. This creates a new prediction key for this scope (FScopedPredictionWindow::ScopedPredictionKey).\u003c/p\u003e\n\n\u003cp\u003eClient calls AbilitySystemComponent-\u003eServerInputRelease which passes ScopedPrediction.ScopedPredictionKey as a parameter.\u003c/p\u003e\n\n\u003cp\u003eServer runs ServerInputRelease_Implementation which takes the passed in PredictionKey and sets it as UAbilitySystemComponent::ScopedPredictionKey with an \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FScopedPredictionWindow\"\u003eFScopedPredictionWindow\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eServer runs \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/Abilities/Tasks/UAbilityTask_WaitInputRelease/OnReleaseCallbac-\"\u003eUAbilityTask_WaitInputRelease::OnReleaseCallback\u003c/a\u003e /within the same scope/\u003c/p\u003e\n\n\u003cp\u003eWhen the server hits the \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FScopedPredictionWindow\"\u003eFScopedPredictionWindow\u003c/a\u003e in ::OnReleaseCallback, it gets the prediction key from UAbilitySystemComponent::ScopedPredictionKey. That is now used for all side effects within this logical scope.\u003c/p\u003e\n\n\u003cp\u003eOnce the server ends this scoped prediction window, the prediction key used is finished and set to ReplicatedPredictionKey.\u003c/p\u003e\n\n\u003cp\u003eAll side effects created in this scope now share a key between client and server.\u003c/p\u003e\n\n\u003cp\u003eThe key to this working is that ::OnReleaseCallback calls ::ServerInputRelease which calls ::OnReleaseCallback on the server. There is no room for anything else to happen and use the given prediction key.\u003c/p\u003e\n\n\u003cp\u003eWhile there is no \"Try/Failed/Succeed\" calls in this example, all side effects are procedurally grouped/atomic. This solves the \"Undo\" and \"Redo\" problems for any arbitrary function calls that run on the server and client.\u003c/p\u003e\n\n\u003cp\u003eUnsupported / Issues/ Todo\u003c/p\u003e\n\n\u003cp\u003eTriggered events do not explicitly replicate. E.g., if a triggered event only runs on the server, the client will never hear about it. This also prevents us from doing cross player/AI etc events. Support for this should eventually be added and it should follow the same pattern that GameplayEffect and GameplayCues follow (predict triggered event with a prediction key, ignore the RPC event if it has a prediction key).\u003c/p\u003e\n\n\u003cp\u003eBig caveat with this whole system: Rollback of any chained activations (including triggered events) is currently not possible out of the box. The reason for this is because each ServerTryActivateAbility is going to be responded to in order. Let's chain dependent GA's as an example: GA_Mispredict -\u003e GA_Predict1. In this example, when GA_Mispredict is activated and predicted locally it will immediately also activate GA_Predict1. The client sends ServerTryActivateAbility for GA_Mispredict, and the server rejects it (sending back a ClientActivateAbilityFailed). As it stands, we don't have any delegates that reject dependent abilities on the client (and the server isn't even aware there are dependencies). On the server, it also receives a ServerTryActivateAbility for GA_Predict1. Assuming that succeeds, the Client and Server are now both executing GA_Predict1 even though GA_Mispredict never happened. You can design around this by using the tag system to ensure GA_Mispredict succeeded.\u003c/p\u003e\n\n\u003cp\u003e*** Predicting \"Meta\" Attributes such as Damage/Healing vs \"real\" attributes such as Health ***\u003c/p\u003e\n\n\u003cp\u003eWe are unable to apply meta attributes predictively. Meta attributes only work on instant effects, in the back end of GameplayEffect (Pre/Post Modify Attribute on the \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/UAttributeSet\"\u003eUAttributeSet\u003c/a\u003e). These events are not called when applying duration-based gameplay effects. E.g., a GameplayEffect that modifies damage for 5 seconds doesn't make sense.\u003c/p\u003e\n\n\u003cp\u003eIn order to support this, we would probably add some limited support for duration based meta attributes, and move the transform of the instant gameplay effect from the front end (UAbilitySystemComponent::ApplyGameplayEffectSpecToSelf) to the backend (UAttributeSet::PostModifyAttribute).\u003c/p\u003e\n\n\u003cp\u003e*** Predicting ongoing multiplicative GameplayEffects ***\u003c/p\u003e\n\n\u003cp\u003eThere are also limitations when predicting % based gameplay effects. Since the server replicates down the 'final value' of an attribute, but not the entire aggregator chain of what is modifying it, we may run into cases where the client cannot accurately predict new gameplay effects.\u003c/p\u003e\n\n\u003cp\u003eFor example: -Client has a perm +10% movement speed buff with base movement speed of 500 -\u003e 550 is the final movement speed for this client. -Client has an ability which grants an additional 10% movement speed buff. It is expected to \u003cem\u003esum\u003c/em\u003e the % based multipliers for a final 20% bonus to 500 -\u003e 600 movement speed. -However on the client, we just apply a 10% buff to 550 -\u003e 605.\u003c/p\u003e\n\n\u003cp\u003eThis will need to be fixed by replicating down the aggregator chain for attributes. We already replicate some of this data, but not the full modifier list. We will need to look into supporting this eventually.\u003c/p\u003e\n\n\u003cp\u003e*** \"Weak Prediction\" ***\u003c/p\u003e\n\n\u003cp\u003eWe will probably still have cases that do not fit well into this system. Some situations will exist where a prediction key exchange is not feasible. For example, an ability where any one that player collides with/touches receives a GameplayEffect that slows them and their material blue. Since we can't send Server RPCs every time this happens (and the server couldn't necessarily handle the message at its point in the simulation), there is no way to correlate the gameplay effect side effects between client and server.\u003c/p\u003e\n\n\u003cp\u003eOne approach here may be to think about a weaker form of prediction. One where there is not a fresh prediction key used and instead the server assumes the client will predict all side effects from an entire ability. This would at least solve the \"redo\" problem but would not solve the \"completeness\" problem. If the client side prediction could be made as minimal as possible - for example only predicting an initial particle effect rather than predicting the state and attribute change - then the problems get less severe.\u003c/p\u003e\n\n\u003cp\u003eI can envision a weak prediction mode which is what (certain abilities? All abilities?) fall back to when there is no fresh prediction key that can accurately correlate side effects. When in weak prediction mode, perhaps only certain actions can be predicted - for example GameplayCue execute events, but not OnAdded/OnRemove events. \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e is a generic way of supporting Clientside Prediction in the GameplayAbility system. A \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e is essentially an ID for identifying predictive actions and side effects that are done on a client. UAbilitySystemComponent supports synchronization of the prediction key and its side effects between client and server.\u003c/p\u003e\n\n\u003cp\u003eEssentially, anything can be associated with a PredictionKey, for example activating an Ability. The client can generate a fresh PredictionKey and sends it to the server in its ServerTryActivateAbility call. The server can confirm or reject this call (ClientActivateAbilitySucceed/Failed).\u003c/p\u003e\n\n\u003cp\u003eWhile the client is predicting its ability, it is creating side effects (GameplayEffects, TriggeredEvents, Animations, etc). As the client predicts these side effects, it associates each one with the prediction key generated at the start of the ability activation.\u003c/p\u003e\n\n\u003cp\u003eIf the ability activation is rejected, the client can immediately revert these side effects. If the ability activation is accepted, the client must wait until the replicated side effects are sent to the server. (the ClientActivatbleAbilitySucceed RPC will be immediately sent. Property replication may happen a few frames later). Once replication of the server created side effects is finished, the client can undo its locally predictive side effects.\u003c/p\u003e\n\n\u003cp\u003eThe main things \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e itself provides are: -Unique ID and a system for having dependant chains of Prediction Keys (\"Current\" and \"Base\" integers) -A special implementation of \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NetSerialize\"\u003eNetSerialize\u003c/a\u003e *** which only serializes the prediction key to the predicting client *** -This is important as it allows us to serialize prediction keys in replicated state, knowing that only clients that gave the server the prediction key will actually see them!\u003c/p\u003e\n\n\u003ch2\u003eVariables\u003c/h2\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003eType\u003c/th\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/52b7c869-f3f2-41b9-b4d9-ec45a9573f80/api_variable_public.png\" alt=\"Public variable\" loading=\"lazy\" title=\"Public variable\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/3c3c33b6-97e0-49d9-bee2-ae89ab43dff7/api_variable_meta.png\" alt=\"UProperty\" loading=\"lazy\" title=\"UProperty\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/106e8155-6471-4ee9-8b8f-98c5a2ef7c2a/api_variable_meta_other.png\" alt=\"notreplicated\" loading=\"lazy\" title=\"notreplicated\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/HAL/int16\"\u003eint16\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eBase\u003c/td\u003e\n      \u003ctd\u003eIf non 0, the original prediction key this was created from (in a dependency chain)\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/5cb90de2-2e98-4e52-bd7d-06de6ad7921b/api_variable_public.png\" alt=\"Public variable\" loading=\"lazy\" title=\"Public variable\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/216aae47-f629-4292-9c09-6bc7431db597/api_variable_meta.png\" alt=\"UProperty\" loading=\"lazy\" title=\"UProperty\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003ebIsServerInitiated\u003c/td\u003e\n      \u003ctd\u003eTrue if this was created as a server initiated activation key, used to identify server activations but cannot be used for prediction\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/473b03f7-319c-49e7-8abc-a4a64b7857e4/api_variable_public.png\" alt=\"Public variable\" loading=\"lazy\" title=\"Public variable\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/0e7414c1-cc84-4d74-bb2a-8f3407386079/api_variable_meta.png\" alt=\"UProperty\" loading=\"lazy\" title=\"UProperty\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/HAL/int16\"\u003eint16\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003eCurrent\u003c/td\u003e\n      \u003ctd\u003eThe unique ID of this prediction key\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eConstructors\u003c/h2\u003e\n\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003eType\u003c/th\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/fac050a3-87d0-4e89-a586-b8aeca8c89f5/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/__ctor/1\"\u003eFPredictionKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eFunctions\u003c/h2\u003e\n\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003eType\u003c/th\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/854c4769-5d70-41b4-bba0-b3cd12c03641/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/26352f2f-adc8-4077-a2a6-55cb2e89a9ee/api_function_static.png\" alt=\"Static\" loading=\"lazy\" title=\"Static\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/CreateNewPredictionKey\"\u003eCreateNewPredictionKey\u003c/a\u003e\n (\nconst UAbilitySystemComponent*\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eConstruct a new prediction key with no dependencies\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/18fecc06-5a7a-461d-8184-789f2f7938c8/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/dc6aea66-4699-470d-b913-6f041621babc/api_function_static.png\" alt=\"Static\" loading=\"lazy\" title=\"Static\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/CreateNewServerInitiatedKey\"\u003eCreateNewServerInitiatedKey\u003c/a\u003e\n (\nconst UAbilitySystemComponent*\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eConstruct a new server initiation key, for abilities activated on the server\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/1662dbd5-0fcb-4dac-9676-2e1459725423/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003evoid\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/GenerateDependentPredictionKey\"\u003eGenerateDependentPredictionKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eCreate a new dependent prediction key: keep our existing base or use the current key as the base.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/a00c928f-6ffd-4e2d-96f2-6a87b55c6983/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/ac896fd1-7a84-4eaf-bf65-7813e53daa5d/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/HAL/uint64\"\u003euint64\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/GetPredictiveConnectionKey\"\u003eGetPredictiveConnectionKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/ddc69e16-51fd-4095-9982-fe81cfdcc212/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/2cdd1890-16c5-4eba-bb48-a9e0ce78dfc3/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/IsLocalClientKey\"\u003eIsLocalClientKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eA key was generated by the local client if it's valid and not a server key, prediction keys for other clients will serialize down as 0 and be invalid\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/d19dc03c-f6ae-44ea-80e7-8bab735686a0/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/3bb7ba6f-ea25-4ae5-a51e-2722d4ef62c5/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/IsServerInitiatedKey\"\u003eIsServerInitiatedKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eTrue if this was created as a server initiated activation key, used to identify server activations but cannot be used for prediction\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/11d83149-3b54-4093-9daf-b08ac4aa0fa6/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/48a0079f-28c6-4ef0-ac1e-e07b2b14acf7/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/IsValidForMorePrediction\"\u003eIsValidForMorePrediction\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eCan this key be used for more predictive actions, or has it already been sent off to the server?\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/7c5872b3-ab54-43e7-8fd2-698d38ac883a/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/fc1dfd93-1716-42da-90a7-d3c2fb9dc5fa/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/IsValidKey\"\u003eIsValidKey\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eA key is valid if it's non-zero, prediction keys for other clients will serialize down as 0 and be invalid\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/f90c593e-487e-477f-9f55-4765bf41b8dd/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NetSerialize\"\u003eNetSerialize\u003c/a\u003e\n (\n\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Serialization/FArchive\"\u003eFArchive\u003c/a\u003e\u0026 Ar,\u003cbr\u003e\n\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/CoreUObject/UObject/UPackageMap\"\u003eUPackageMap\u003c/a\u003e* Map,\u003cbr\u003e\nbool\u0026 bOutSuccess\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eThe key to understanding this function is that when a key is received by the server, we note which connection gave it to us.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/b93692b2-983f-4689-af90-094641ae8459/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKeyEvent\"\u003eFPredictionKeyEvent\u003c/a\u003e \u0026\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NewCaughtUpDelegate\"\u003eNewCaughtUpDelegate\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eCreates new delegate called only when replicated state catches up to this key.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/fcea2958-1e92-4b16-aabc-50d8f405cf33/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKeyEvent\"\u003eFPredictionKeyEvent\u003c/a\u003e \u0026\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NewRejectedDelegate\"\u003eNewRejectedDelegate\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eCreates new delegate called only when this key is rejected.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/66ab8d06-2139-44b7-ad19-869b95c816ec/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003evoid\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/NewRejectOrCaughtUpDelegate\"\u003eNewRejectOrCaughtUpDelegate\u003c/a\u003e\n (\n\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKeyEvent\"\u003eFPredictionKeyEvent\u003c/a\u003e Event\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eAdd a new delegate that is called if the key is rejected or caught up to.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/a839e0b1-2131-4b24-b1cc-5c9ebccf01b9/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/cf89150a-9210-40d1-93e2-7f47a7cf95e6/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/TraceLog/FString\"\u003eFString\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/ToString\"\u003eToString\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/71e7719c-9764-4daf-96d9-897fccb3ede5/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/09af8d20-e4a9-45c3-a7cc-feb468dad060/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/WasLocallyGenerated\"\u003eWasLocallyGenerated\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/7dddc435-1aa3-48b0-9af8-e53606e86e21/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/3efe434a-0aed-46ba-ba53-34c3e639274e/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/WasReceived\"\u003eWasReceived\u003c/a\u003e ()\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eWas this PredictionKey received from a NetSerialize or created locally?\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eOperators\u003c/h2\u003e\n\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003eType\u003c/th\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/c0293eb5-c097-4f5c-a41f-8c47762fed7b/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/fdd675cd-b2ec-49a8-87cf-fbafb4df3a30/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/op_cmp_ne\"\u003eoperator!=\u003c/a\u003e\n (\nconst \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e\u0026 Other\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/21b58b5c-c464-40bb-b804-fb2af92185a2/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/f42f9cbe-9c44-4cf7-8b99-47ad38c00a9e/api_function_const.png\" alt=\"Const\" loading=\"lazy\" title=\"Const\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003ebool\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/op_cmp_eq\"\u003eoperator==\u003c/a\u003e\n (\nconst \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey\"\u003eFPredictionKey\u003c/a\u003e\u0026 Other\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eTypedefs\u003c/h2\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/GameplayAbilities/FPredictionKey/KeyType\"\u003eKeyType\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n",
      "settings": {
        "is_hidden": false
      },
      "type": "markdown"
    }
  ],
  "description": "Overview of Gameplay Ability Prediction",
  "document_type": null,
  "hash_id": "BjaeE",
  "id": 3375375,
  "locale": "en-us",
  "prereq_documents": [],
  "readiness": "production",
  "related_documents": [],
  "revision_hash_id": "aB2rk",
  "seo_description": null,
  "seo_slug": null,
  "seo_title": null,
  "slug": "API/Plugins/GameplayAbilities/FPredictionKey",
  "source": "ue_cpp_api_external",
  "tags": [],
  "title": "FPredictionKey",
  "updated_at": "2024-11-13T05:11:04.708+00:00",
  "views_count": 14
}