{
  "application_families": [
    "unreal_engine"
  ],
  "applications": [
    {
      "id": 3581142,
      "major_version": "5",
      "type": "unreal_engine",
      "version": "5.5"
    }
  ],
  "blocks": [
    {
      "content_html": "\u003ch2\u003eNavigation\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API\"\u003eUnreal Engine C++ API Reference\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins\"\u003ePlugins\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore\"\u003eSQLiteCore\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite\"\u003esqlite\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eType\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003etypedef struct sqlite3_io_methods sqlite3_io_methods  \n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eReferences\u003c/h2\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003e \u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eModule\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore\"\u003eSQLiteCore\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eHeader\u003c/td\u003e\n      \u003ctd\u003e/Engine/Plugins/Runtime/Database/SQLiteCore/Source/SQLiteCore/Public/sqlite/sqlite3.h\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eInclude\u003c/td\u003e\n      \u003ctd\u003e#include \"sqlite/sqlite3.h\"\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eRemarks\u003c/h2\u003e\n\n\u003cp\u003eCAPI3REF: OS Interface File Virtual Methods Object\u003c/p\u003e\n\n\u003cp\u003eEvery file opened by the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_vfs_1/xOpen\"\u003esqlite3_vfs.xOpen\u003c/a\u003e] method populates an [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_file_1\"\u003esqlite3_file\u003c/a\u003e] object (or, more commonly, a subclass of the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_file_1\"\u003esqlite3_file\u003c/a\u003e] object) with a pointer to an instance of this object. This object defines the methods used to perform various operations against the open file represented by the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_file_1\"\u003esqlite3_file\u003c/a\u003e] object.\u003c/p\u003e\n\n\u003cp\u003eIf the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_vfs_1/xOpen\"\u003esqlite3_vfs.xOpen\u003c/a\u003e] method sets the \u003ca href=\"https://dev.epicgames.com/documentation/404\"\u003esqlite3_file.pMethods\u003c/a\u003e element to a non-NULL pointer, then the \u003ca href=\"https://dev.epicgames.com/documentation/404\"\u003esqlite3_io_methods.xClose\u003c/a\u003e method may be invoked even if the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_vfs_1/xOpen\"\u003esqlite3_vfs.xOpen\u003c/a\u003e] reported that it failed. The only way to prevent a call to xClose following a failed [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_vfs_1/xOpen\"\u003esqlite3_vfs.xOpen\u003c/a\u003e] is for the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_vfs_1/xOpen\"\u003esqlite3_vfs.xOpen\u003c/a\u003e] to set the \u003ca href=\"https://dev.epicgames.com/documentation/404\"\u003esqlite3_file.pMethods\u003c/a\u003e element to NULL.\u003c/p\u003e\n\n\u003cp\u003eThe flags argument to xSync may be one of [SQLITE_SYNC_NORMAL] or [SQLITE_SYNC_FULL]. The first choice is the normal fsync(). The second choice is a Mac OS X style fullsync. The [SQLITE_SYNC_DATAONLY] flag may be ORed in to indicate that only the data of the file and not its inode needs to be synced.\u003c/p\u003e\n\n\u003cp\u003eThe integer values to xLock() and xUnlock() are one of\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003e[SQLITE_LOCK_NONE],\u003c/li\u003e\n  \u003cli\u003e[SQLITE_LOCK_SHARED],\u003c/li\u003e\n  \u003cli\u003e[SQLITE_LOCK_RESERVED],\u003c/li\u003e\n  \u003cli\u003e[SQLITE_LOCK_PENDING], or\u003c/li\u003e\n  \u003cli\u003e[SQLITE_LOCK_EXCLUSIVE].\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003exLock() increases the lock. xUnlock() decreases the lock. The xCheckReservedLock() method checks whether any database connection, either in this process or in some other process, is holding a RESERVED, PENDING, or EXCLUSIVE lock on the file. It returns true if such a lock exists and false otherwise.\u003c/p\u003e\n\n\u003cp\u003eThe xFileControl() method is a generic interface that allows custom VFS implementations to directly control an open file using the [\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Plugins/SQLiteCore/sqlite/sqlite3_file_control\"\u003esqlite3_file_control()\u003c/a\u003e] interface. The second \"op\" argument is an integer opcode. The third argument is a generic pointer intended to point to a structure that may contain arguments or space in which to write return values. Potential uses for xFileControl() might be functions to enable blocking locks with timeouts, to change the locking strategy (for example to use dot-file locks), to inquire about the status of a lock, or to break stale locks. The SQLite core reserves all opcodes less than 100 for its own use. A [file control opcodes | list of opcodes] less than 100 is available. Applications that define a custom xFileControl method should use opcodes greater than 100 to avoid conflicts. VFS implementations should return [SQLITE_NOTFOUND] for file control opcodes that they do not recognize.\u003c/p\u003e\n\n\u003cp\u003eThe xSectorSize() method returns the sector size of the device that underlies the file. The sector size is the minimum write that can be performed without disturbing other bytes in the file. The xDeviceCharacteristics() method returns a bit vector describing behaviors of the underlying device:\u003c/p\u003e\n\n\u003cul\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC512]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC1K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC2K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC4K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC8K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC16K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC32K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_ATOMIC64K]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_SAFE_APPEND]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_SEQUENTIAL]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_POWERSAFE_OVERWRITE]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_IMMUTABLE]\u003c/li\u003e\n  \u003cli\u003e[SQLITE_IOCAP_BATCH_ATOMIC]\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThe SQLITE_IOCAP_ATOMIC property means that all writes of any size are atomic. The SQLITE_IOCAP_ATOMICnnn values mean that writes of blocks that are nnn bytes in size and are aligned to an address which is an integer multiple of nnn are atomic. The SQLITE_IOCAP_SAFE_APPEND value means that when data is appended to a file, the data is appended first then the size of the file is extended, never the other way around. The SQLITE_IOCAP_SEQUENTIAL property means that information is written to disk in the same order as calls to xWrite().\u003c/p\u003e\n\n\u003cp\u003eIf xRead() returns SQLITE_IOERR_SHORT_READ it must also fill in the unread portions of the buffer with zeros. A VFS that fails to zero-fill short reads might seem to work. However, failure to zero-fill short reads will eventually lead to database corruption.\u003c/p\u003e\n",
      "settings": {
        "is_hidden": false
      },
      "type": "markdown"
    }
  ],
  "description": "CAPI3REF: OS Interface File Virtual Methods Object",
  "document_type": null,
  "hash_id": "YLLQLr",
  "id": 3856593,
  "locale": "en-us",
  "prereq_documents": [],
  "readiness": "production",
  "related_documents": [],
  "revision_hash_id": "Vzzrvx",
  "seo_description": null,
  "seo_slug": null,
  "seo_title": null,
  "slug": "API/Plugins/SQLiteCore/sqlite/sqlite3_io_methods",
  "source": "ue_cpp_api_external",
  "tags": [],
  "title": "sqlite3_io_methods",
  "updated_at": "2024-11-13T12:59:57.612+00:00",
  "views_count": 0
}