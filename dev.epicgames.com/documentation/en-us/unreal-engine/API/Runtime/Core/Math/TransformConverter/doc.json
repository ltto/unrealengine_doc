{
  "application_families": [
    "unreal_engine"
  ],
  "applications": [
    {
      "id": 3581142,
      "major_version": "5",
      "type": "unreal_engine",
      "version": "5.5"
    }
  ],
  "blocks": [
    {
      "content_html": "\u003ch2\u003eNavigation\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API\"\u003eUnreal Engine C++ API Reference\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime\"\u003eRuntime\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core\"\u003eCore\u003c/a\u003e \u003e \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math\"\u003eMath\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eReferences\u003c/h2\u003e\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003e \u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eModule\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core\"\u003eCore\u003c/a\u003e\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eHeader\u003c/td\u003e\n      \u003ctd\u003e/Engine/Source/Runtime/Core/Public/Math/TransformCalculus.h\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003eInclude\u003c/td\u003e\n      \u003ctd\u003e#include \"Math/TransformCalculus.h\"\u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003ch2\u003eSyntax\u003c/h2\u003e\n\n\u003cpre\u003e\u003ccode\u003etemplate\u0026lt;class TransformType\u0026gt;  \nstruct TransformConverter  \n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eRemarks\u003c/h2\u003e\n\n\u003cp\u003eTransform calculus.\u003c/p\u003e\n\n\u003cp\u003eA Transform represents a frame of reference in a local (often orthonormal) coordinate system. Essentially a transform represents conversion from a local space A to another local space B. Thus, it's commonly written as T[AB]. Keeping this notation of spaces explicit allows transformation calculus to be very simple and easily checked using something akin to dimensional analysis:\u003c/p\u003e\n\n\u003cp\u003eT[AB] * T[BC] =\u003e T[AC] (aka, Concatenate(T[AB], T[BC]) T[AB]^-1 =\u003e T[BA] (aka, Inverse(T[AB])\u003c/p\u003e\n\n\u003cp\u003eConcatenate is illegal if the LHS output space is not equivalent to the RHS input space:\u003c/p\u003e\n\n\u003cp\u003eT[AB] * T[BC] \u003c OK T[BA] * T[BC] \u003c illegal; output space is A, input space is B.\u003c/p\u003e\n\n\u003cp\u003eSo, if you have a spatial hierarchy like so:                A\n            /     \\\n           B       C\n          / \\     / \\\n         D   E   F   G\n                    /\n                   H\u003c/p\u003e\n\n\u003cp\u003eYou can easily construct the math to move from, say, Space D to Space H using notation purely in terms of the forward transforms that define the hierarchy:\u003c/p\u003e\n\n\u003cp\u003eT[DH] = T[DB] * T[BA] * T[CA]^-1 * T[GC]^-1 * T[HG]^-1\u003c/p\u003e\n\n\u003cp\u003eFrom a code standpoint, this gives us a well-defined set of methods that can be called on anything that can be interpreted as a transform and let it work uniformly. Matrices, Quats, Vectors, Scalars, and other custom classes that are unambiguously defined as transformational spaces can be concatenated together with a well-defined meaning.\u003c/p\u003e\n\n\u003cp\u003eFundamental Operations\u003c/p\u003e\n\n\u003cp\u003eThe fundamental components of the Transform library are a collection of non-member functions (and their overloads):\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eConcatenate(TransformA, TransformB)\u003c/li\u003e\n  \u003cli\u003eInverse(Transform)\u003c/li\u003e\n  \u003cli\u003eTransformPoint(Transform, Point)\u003c/li\u003e\n  \u003cli\u003eTransformVector(Transform, Vector)\u003c/li\u003e\n  \u003cli\u003eTransformCast\u003cResult, Transform\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eThese operations are NOT member functions to support existing classes in UE4 without modification, and to more easily support extending the supported types with other existing classes.Concatenate\u003c/p\u003e\n\n\u003cp\u003eGeneralized transform concatenation. It exists to ensure that any two classes that can be thought of as transformational spaces (listed above, along with any user-defined classes), can be combined uniformly with well defined semantics. For example, given A * B in UE4 means two different things if A and B are matrices or quaternions. Concatenate abstracts this notion into an explicit syntax for combining transforms instead of focusing on the mathematical notation.\u003c/p\u003e\n\n\u003cp\u003eThe result of a concatenate operation depends on the types concatenated, but are guaranteed to be another type that supports the fundamental operations. For instance, concatenating two translations results in another translation, but concatenating a rotation followed by a translation might result in a FMatrix, or potentially another class that efficiently contains this transformation (like maybe a class that holds a scalar+quat+vector).\u003c/p\u003e\n\n\u003cp\u003eGenerally you should not have to worry about the return type. Just Concatenate and then use another fundamental operation to transform a position and/or vector through that space. When you need to store the result you can either use auto, assume the type, or use TransformCast (covered below) to ensure the type.\u003c/p\u003e\n\n\u003cp\u003eIn certain rare cases, the result of Concatenate may be ambiguous (FRotator or FQuat?). In such cases, there is a Concatenate template overload that allows you to explicitly specify the ResultType. This should rarely be necessary.Inverse\u003c/p\u003e\n\n\u003cp\u003eGeneralized transform inversion. Takes a transform from space A to space B and returns a transform that goes from space B to space A. The output type is guaranteed to be the same.Transform[Point|Vector]\u003c/p\u003e\n\n\u003cp\u003eThe primary reason to construct a transform from space A to B is to transform things from space A to space B. TransformPoint does this for points in space, and TransformVector does this for vectors (extents or normals) in space.\u003c/p\u003e\n\n\u003cp\u003eThere are 2D variants for efficiency. All functions assume a non-projective transform (ie, they don't perform a homogeneous divide). The output type is guaranteed to be the same as the input.TransformCast\u003cResult, Transform\u003e\u003c/p\u003e\n\n\u003cp\u003eThe job of the TransformCast is to provide efficient conversion from one transform type to another, when possible. This is typically done to store the transform in a specific variable type after a sequence of Concatenate and Inverse calls.\u003c/p\u003e\n\n\u003cp\u003eNot all transforms can be cast. For instance, a scale cannot be cast to a translation. Usually the output of a cast operation is a generalized transform type like FTransform, FMatrix, etc.\u003c/p\u003e\n\n\u003cp\u003eTransformCast supports efficient identity pass-through (Type A -\u003e Type A) so applying a cast in generic code is safe and fast (no copying).\u003c/p\u003e\n\n\u003cp\u003eImplementing a custom type.\u003c/p\u003e\n\n\u003cp\u003eWhile UE4 supports a wide variety of transforms, there is sometimes need to support another custom transform type. The core code provides basic scaffolding and a set of recommended practices to make this as easy as possible. This allows most of the functionality to be provided via member functions in the new custom type, while still allowing existing types to be adapted via non-member functions if you choose to do it that way. However, you will need to understand a few of the underlying templatized helpers that make this possible:\u003c/p\u003e\n\u003cul\u003e\n  \u003cli\u003eTransformConverter\u003cT\u003e\u003c/li\u003e\n  \u003cli\u003eConcatenateRules\u003cT1, T2\u003e\nTransformConverter\u003cT\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eTransformConverter\u003c\u003e implements the meat of TransformCast. It does it's work through the templatized static member function Convert\u003cT2\u003e. By default this method uses a conversion ctor to construct a T from a T2. Therefore your class can either provide such conversion ctors or specialize \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter/Convert/1\"\u003eTransformConverter\u003cT\u003e::Convert\u003cT2\u003e\u003c/a\u003e for each transform type you can cast to.\u003c/p\u003e\n\n\u003cp\u003eThis class is a template struct with a template member to effectively allow partial specialization of either parameter, which function templates do no support. We need to call this as an explicit template call, so non-template overloads are not an option. We also need this to support partial specialization for the NULL conversion.ConcatenateRules\u003cT1, T2\u003e\u003c/p\u003e\n\n\u003cp\u003eIn general, the result of a Concatenate call cannot be predicted by the template code. For instance, what is the result of Concatenate(FQuat, FRotator)? What if there are more than one type that can contain the transform (like FMatrix and FTransform)? \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/Concatenate/1\"\u003eConcatenate()\u003c/a\u003e generally relies on overloads (template or non-template) to do the work. However, requiring all combinations of all types to be overloaded would be quite tedious, and generally unnecessary. Therefore, Concatenate supports a general template form that first converts both parameters to the appropriate return type via TransformCast\u003c\u003e, then calls Concatentate on those: return Concatenate(TransformCast\u003cResult\u003e(LHS), TransformCast\u003cResult\u003e(RHS));\u003c/p\u003e\n\n\u003cp\u003eThis makes it convenient to automatically support flexible concatenation by leveraging the conversion mechanics of TransformCast\u003c\u003e.\u003c/p\u003e\n\n\u003cp\u003eBut how does one determine the \"appropriate\" return type? This is done via the ConcatenateRules\u003cT1, T2\u003e template, which simply defines the appropriate ResultType for Concatenate\u003cT1, T2\u003e: typedef XXX ResultType;\u003c/p\u003e\n\n\u003cp\u003eThe default implementation is empty, meaning there is no support available. There is a partial specialization for the same types so the code can always assume that Concatenate\u003cT,T\u003e -\u003e T.\u003c/p\u003e\n\n\u003cp\u003eRemember that TransformCast\u003cT,T\u003e is a NOOP, so this works efficiently.\u003c/p\u003e\n\n\u003cp\u003eIt is up to the implementor of a custom class to define any additional \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/ConcatenateRules\"\u003eConcatenateRules\u003c/a\u003e for their new type.\u003c/p\u003e\n\n\u003cp\u003eAlso note that implementing every Concatenate by first upcasting each parameter to the result type may not be very efficient. In those cases, providing direct, non-template overload of Concatenate may be better. See the example below for details.\u003c/p\u003e\n\n\u003cp\u003eExample Custom type\u003c/p\u003e\n\n\u003cp\u003eSay you wanted to create a type that only supports uniform scale followed by 3D translation. Let's call this type TranformST for shorthand.\u003c/p\u003e\n\n\u003cp\u003eThe core code provides default template implementations that pass through to member functions of the custom type. This allows most of the functionality to be centralized in the new custom type, while still allowing for non-member overloads if you choose to do it that way.\u003c/p\u003e\n\n\u003cp\u003eThe following class skeleton provides the basic signature of a class that supports the Transform Calculus:\u003c/p\u003e\n\n\u003cp\u003eclass FTransformST { public: explicit FTransformST(float InScale); // 1. Used by: \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter\"\u003eTransformConverter\u003c/a\u003e explicit FTransformST(const FVector\u0026 InTranslation); // 1. Used by: \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter\"\u003eTransformConverter\u003c/a\u003e FMatrix ToMatrix() const; // 2. (OPTIONAL) Used by: TransformConverter\u003cFMatrix\u003e FVector TransformPoint(const FVector\u0026 Point) const; // 3. Used by: TransformPoint FVector TransformVector(const FVector\u0026 Vector) const; // 4. Used by: TransformVector FTransformST Concatenate(const FTransformST\u0026 RHS) const; // 5. Used by: Concatenate FTransformST Inverse() const; // 6. Used by: Inverse };\u003c/p\u003e\n\n\u003cp\u003einline FTransformST Concatenate(float LHS, const FVector\u0026 RHS); // 7. (OPTIONAL) Used by: Concatenate inline FTransformST Concatenate(const FVector\u0026 LHS, float RHS); // 7. (OPTIONAL) Used by: Concatenate\u003c/p\u003e\n\n\u003cp\u003etemplate\u003c\u003e struct ConcatenateRules\u003cFTransformST, float       \u003e { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template\u003c\u003e struct ConcatenateRules\u003cfloat       , FTransformST\u003e { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template\u003c\u003e struct ConcatenateRules\u003cFTransformST, FVector     \u003e { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate template\u003c\u003e struct ConcatenateRules\u003cFVector     , FTransformST\u003e { typedef FTransformST ResultType; }; // 8. (OPTIONAL) Used by: Concatenate\u003c/p\u003e\n\n\u003cp\u003etemplate\u003c\u003e struct ConcatenateRules\u003cFTransformST, FMatrix     \u003e { typedef FMatrix ResultType; }; // 9. (OPTIONAL) Used by: Concatenate template\u003c\u003e struct ConcatenateRules\u003cFMatrix     , FTransformST\u003e { typedef FMatrix ResultType; }; // 9. (OPTIONAL) Used by: Concatenate\u003c/p\u003e\n\n\u003cp\u003eProvide conversion constructors (can be explicit) to convert a lower level transform into this higher level one. In this case, we can convert any translation or scale to a FTransformST. This will be used by the Concatenate rules below to upcast any lower level types so they can be concatenated together.\u003c/p\u003e\n\n\u003cp\u003e(OPTIONAL) Provide a ToMatrix function to allow this type to be concatenated with FMatrix automatically (which is a common fundamental transform). There is a specialization of \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter\"\u003eTransformConverter\u003c/a\u003e for FMatrix that looks for this member function as a convenience to custom class providers.\u003c/p\u003e\n\n\u003cp\u003eProvide a TransformPoint method (and perhaps a 2D version) which will be used by the default template implementation of TransformPoint. If you choose not to provide a member function, you can instead provide a non-template overload of TransformPoint(FTransformTS, FVector).\u003c/p\u003e\n\n\u003cp\u003eProvide a TransformVector method (and perhaps a 2D version) which will be used by the default template implementation of TransformPoint. If you choose not to provide a member function, you can instead provide a non-template overload of TransformVector(FTransformTS, FVector).\u003c/p\u003e\n\n\u003cp\u003eProvide a Concatenate method which will be used by the default template implementation of Concatenate. If you choose not to provide a member function, you can instead provide a non-template overload of Concatenate(FTransformTS, FTransformTS).\u003c/p\u003e\n\n\u003cp\u003eProvide a Inverse method which will be used by the default template implementation of Inverse. If you choose not to provide a member function, you can instead provide a non-template overload of Inverse(FTransformTS).\u003c/p\u003e\n\n\u003cp\u003eProvide some specializations of Concatenate that more efficiently represent the transforms your class supports. In this case, our class can represent an arbitrary combination of uniform scale and translation, so by providing explicit overloads, these more efficient versions will be used instead of promoting both types to FTransformST first.\u003c/p\u003e\n\n\u003cp\u003eSince we don't provide explicit Concatenate combinations for all possibly types (we could), we provide some ConcatenateRules\u003c\u003e to allow the default Concatenate implementation to work with scalars and transform vectors.\u003c/p\u003e\n\n\u003cp\u003eWe also provide a set of \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/ConcatenateRules\"\u003eConcatenateRules\u003c/a\u003e for FMatrix. This ends up using the ToMatrix member function we provided in 2. Provides default logic (used by TransformCast) to convert one transform type to another via a conversion ctor.\u003c/p\u003e\n\n\u003ch2\u003eSpecializations\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter_FMatrix44d\"\u003eTransformConverter\u003c FMatrix44d \u003e\u003c/a\u003e\u003cbr /\u003e\n\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter_FMatrix44f\"\u003eTransformConverter\u003c FMatrix44f \u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eFunctions\u003c/h2\u003e\n\n\n\u003ctable\u003e\n  \u003cthead\u003e\n    \u003ctr\u003e\n      \u003cth\u003e \u003c/th\u003e\n      \u003cth\u003eType\u003c/th\u003e\n      \u003cth\u003eName\u003c/th\u003e\n      \u003cth\u003eDescription\u003c/th\u003e\n    \u003c/tr\u003e\n  \u003c/thead\u003e\n  \u003ctbody\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/569d4c42-a99f-4e52-a621-3d690b5c2ae1/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/adc71f11-61c5-4d25-b103-4d506ab4100a/api_function_static.png\" alt=\"Static\" loading=\"lazy\" title=\"Static\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003econst TransformType \u0026\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter/Convert/1\"\u003eConvert\u003c/a\u003e\n (\nconst TransformType\u0026 Transform\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eEfficient NULL conversion.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/cb32487f-15b9-4338-b26c-8b169e17f447/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e \u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/1c743d6e-242a-4591-89d9-c6bf62a750ce/api_function_static.png\" alt=\"Static\" loading=\"lazy\" title=\"Static\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003eTransformType\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter/Convert/2\"\u003eConvert\u003c/a\u003e\n (\nconst OtherTransformType\u0026 Transform\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eDefault Conversion via a conversion ctor.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/684e2b18-3c61-4568-b351-3ed4da5f56af/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FRotator3f\"\u003eFRotator3f\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter/Convert/3\"\u003eConvert\u003c/a\u003e\n (\nconst \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FMatrix44f\"\u003eFMatrix44f\u003c/a\u003e\u0026 Transform\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003eSpecialization for converting a FMatrix to an FRotator.\u003c/td\u003e\n    \u003c/tr\u003e\n    \u003ctr\u003e\n      \u003ctd\u003e\u003cimg src=\"https://d1iv7db44yhgxn.cloudfront.net/documentation/images/0a0df38c-7f57-49d5-9bf7-898cb4c13020/api_function_public.png\" alt=\"Public function\" loading=\"lazy\" title=\"Public function\" convert=\"false\" width=\"18\" /\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FRotator3d\"\u003eFRotator3d\u003c/a\u003e\u003c/td\u003e\n      \u003ctd\u003e\u003cdiv\u003e\n\u003cp\u003e\u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/TransformConverter/Convert/4\"\u003eConvert\u003c/a\u003e\n (\nconst \u003ca href=\"https://dev.epicgames.com/documentation/en-us/unreal-engine/API/Runtime/Core/Math/FMatrix44d\"\u003eFMatrix44d\u003c/a\u003e\u0026 Transform\u003cbr\u003e\n )\u003c/p\u003e\n\u003c/div\u003e\u003c/td\u003e\n      \u003ctd\u003e \u003c/td\u003e\n    \u003c/tr\u003e\n  \u003c/tbody\u003e\n\u003c/table\u003e\n",
      "settings": {
        "is_hidden": false
      },
      "type": "markdown"
    }
  ],
  "description": "Transform calculus.",
  "document_type": null,
  "hash_id": "K5a4d",
  "id": 3546050,
  "locale": "en-us",
  "prereq_documents": [],
  "readiness": "production",
  "related_documents": [],
  "revision_hash_id": "8bLV8",
  "seo_description": null,
  "seo_slug": null,
  "seo_title": null,
  "slug": "API/Runtime/Core/Math/TransformConverter",
  "source": "ue_cpp_api_external",
  "tags": [],
  "title": "TransformConverter",
  "updated_at": "2024-11-13T17:09:53.686+00:00",
  "views_count": 0
}